<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Component.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Component.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var Flipbase = require('./modules/namespace');
var pubsub = require('./modules/PubSub');
var events = require('./modules/events');
var each = require('./modules/utils').each;
var bind = require('./modules/utils').bind;
var keys = require('./modules/utils').keys;
var createEl = require('./modules/DOM').createEl;
var assign = require('./modules/utils').assign;
var inherits = require('./modules/extendProto');
 /**
  * - Ieder UI component moet dus een HTML string terug geven of niets.
- We kunnen toch in iedere component definieren wanneer de render functie getriggered moet worden?
    -> Enige nadeel is dan wel dat de hele template opnieuw gerendered wordt. 


- In dat geval moet de parent gerendered worden, als in het child een event gebeurd of state verandert.
  -> Kunnen we niet alleen de parent updaten via een trigger? 
    -> Hoe gaan we dat doen als er een component meerdere parents heeft?

  -> Stel we renderen de parent, met de nieuwe state, dan wordt de child bijvoorbeeld niet meer gerendered.
     Dat betekend dat wel wel de instances netjes moeten verwijderen anders leaken die in memory. 
     -> En dat betekend weer dat we moeten diffen om de DOM om de components netjes weg te halen -> VIRTUAL DOM!

Uitzoeken
- Kan ik niet gewoon standaard de volledig app opnieuw renderen? Zo heel veel divs heb ik niet, wellicht is het niet eens erg voor performance!
- Of ik zorg dat "rerendering" niets anders is dan dingen 'hidden' en dan weer tonen. -> cameratag method
- Ik kan zorgen dan components zichzelf kunnen updaten?
  */

/**
 * @example
 * 
 * var $el = new Component('flipbase-recorder-intro', {
 *   tag: 'button',
 *   attrs: {
 *     'style': 'color: #FFF000; text-align: center;'
 *     'className': 'alternative-recorder-intro' // override className as default
 *   }
 * });
 *
 * el.on('click', function (evt) {
 *  // handle click event
 * });
 *
 * el.remove();
 *
 *  
 * 
 * @class
 * @constructor
 */
function Component(options) {
  this._children = {};
  this._events = {};
  this._pubsubs = {};

  /**
  if (options &amp;&amp; (!options.parent &amp;&amp; !options.$el &amp;&amp; !this.createEl)) 
    throw new Error('The top level component should receive an reference to an DOM element');

  this.options = options || {};
  this.parent = options ? options.parent : null;

  // Create new DOM element if there is non provided.
  // If a similar named method has been provided to the parent component's
  // class then this precedes the method as defined in this prototype.
  if (this.createEl) {
    this.$el = this.createEl();
  } else if (this.options.$el) {
    this.$el = this.options.$el;
  }
     
  if (!this.$el)
    this.$el = createEl();

  // If instance does not have a render method provided, render element 
  // directly into the DOM
  // if (!this.render)
    // this.addToDOM();

  // Add child elements to the Component and Render into the DOM
  if (this.children)
    this.addChildren();
  **/

  this.init.call(this, options);
  this._render.apply(this, options);

  return this;
}

Component.prototype = {

  // Needs to be overwritten by instance
  init: function () {},

  /**
   * Internal method that triggers `willRender`, `render` and `didRender` methods
   * synchronously.
   */
  _render: function () {
    this.willRender.apply(this, arguments);
    this.render.apply(this, arguments);
    this.didRender.apply(this, arguments);
  },

  // Methods needs to be overwritten by the instance
  willRender: function () {},
  render: function () {},
  didRender: function () {}

};

/**
Component.prototype.addToDOM = function() {
  if (this.parent &amp;&amp; !document.body.contains(this.$el))
    this.parent.$el.appendChild(this.$el);
};

Component.prototype.listenTo = function (evnt, fn, context, store) {
  context = context || this;
  var index = pubsub.subscribe(evnt, fn, context, store);

  // Added indexes of eventlisteners to local storage, so they can be removed
  if (!this._pubsubs[evnt]) this._pubsubs[evnt] = [];
  this._pubsubs[evnt].push(index);
};

Component.prototype.trigger = function(evnt, store, args) {
  pubsub.publish(evnt, store, args);
};

Component.prototype.unsubscribe = function(evnt, store) {
  var events = this._pubsubs[evnt] || [];
  each(events, function(index) {
    pubsub.unsubscribe(evnt, index, store);
  });
};

Component.prototype.html = function(body) {
  if (typeof body === 'string') {
    this.$el.innerHTML = body;
  }
  return this.$el.innerHTML;
};

Component.prototype.on = function(evt, fn, el) {
  fn = bind(this, fn);
  this._events[evt] = fn;
  el = el || this.$el;
  events.on(el, evt, fn);
};

Component.prototype.off = function(evt, fn, el) {
  fn = this._events[evt] || fn;
  el = el || this.$el;
  events.off(el, evt, fn);
};

Component.prototype.show = function() {
  this.$el.style.display = 'block';
};

Component.prototype.hide = function() {
  this.$el.style.display = 'none';
};

Component.prototype.renderChild = function(child, data) {
  return this._children[child].render(data);
};

Component.prototype.getChild = function(compName) {
  return this._children[compName];
};

// FIXME: models hoeven niet ingepast te worden als args, omdat dit via
// het event system afgehandeld moet worden. 
// We create register a instanceId on each child so we can distribute events
// to an external (globally namespaced) event dispatcher.
Component.prototype.addChildren = function() {
  var _this = this;
  // var model = this.model || {};
  // var client = this.client || {};

  var options = this.options;
  options.playerInstanceId = this.playerInstanceId;
  delete options.$el;

  // Children property is provided by the prototype of the instance
  each(this.children, function(compName) {
    _this.addChild(compName, options);
  });
};

Component.prototype.addChild = function(compName, options) {
  var Comp = this.getComponent(compName);
  options.parent = this;
  
  if (!this._children[compName] &amp;&amp; Comp)
    this._children[compName] = new Comp(options);

  return this._children[compName];
};

Component.prototype.removeChild = function(child) {
  child = this._children[child];
  
  if (child) {
    child.destroy();
    delete this._children[child];
  }
};
  
Component.prototype.remove = function() {
  // If the current component has a parentNode use it
  if (this.$el.parentNode) {
    return this.$el.parentNode.removeChild(this.$el);
  }
};

Component.prototype.destroy = function() {
  var childs = keys(this._children);
  var events = keys(this._events);
  var _this = this;

  if (childs.length)
    this.removeChildren();

  if (events.length)
    each(events, function(key) {
      _this.off(key, events[key]);
    });

  this.remove();

  this.$el = null;
};


Component.getComponent = function(name) {
  if (Component._components[name])
    return Component._components[name];

  // log.error('Component"' + name + '"not registered');
};

Component.registerComponent = function(name, comp) {
  if (!Component._components)
    Component._components = {};

  Component._components[name] = comp;
  return comp;
};
**/

Component.extend = inherits;

module.exports = Component;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-modules_base64.html">modules/base64</a></li><li><a href="module-modules_browser.html">modules/browser</a></li><li><a href="module-modules_cookie.html">modules/cookie</a></li><li><a href="module-modules_DOM.html">modules/DOM</a></li><li><a href="module-modules_events.html">modules/events</a></li><li><a href="module-modules_LogX.html">modules/LogX</a></li><li><a href="module-modules_LogX-console-transport.html">modules/LogX-console-transport</a></li><li><a href="module-modules_LogX-jsonp-transport.html">modules/LogX-jsonp-transport</a></li><li><a href="module-modules_PubSub.html">modules/PubSub</a></li><li><a href="module-modules_utils.html">modules/utils</a></li></ul><h3>Classes</h3><ul><li><a href="Component.html">Component</a></li><li><a href="Model.html">Model</a></li></ul><h3>Namespaces</h3><ul><li><a href="global.html#Flipbase">Flipbase</a></li><li><a href="module-modules_utils-utils.html">utils</a></li></ul><h3>Mixins</h3><ul><li><a href="extendProto.html">extendProto</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-getting-started.html">getting-started</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Sat Oct 24 2015 14:16:34 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
